Date: 2015-11-24
Title: 重构_改善既有代码的设计
Tags: Reading, Refactoring
sulg: Refactoring

## 第一章 重构、第一个案例

### Tips
- 如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构那个程序，是特性的添加比较容易进行，然后再添加特性
- 先看看有没有一套OK的测试机制，这些测试要有自我检测能力
- 尽量干掉一些临时变量，但是需要考虑性能问题
- 函数应该放在它所使用的数据的所属对象内
- 考虑使用多态来替换那些if else, switch case - State 模式
- 测试、小修改、测试、小修改、测试、小修改

### 总结
该重构时就重构，自动化测试是前提，提炼函数，临时变量，switch case，变量名是重点
但是自动化测试一般没有，怎么破？



## 第二章 重构原则
### 正文
- 定义
	- 对软件内部结构的一种调整， 目的是在不改变软件可观查行为的前提下，提高其可理解性，降低其修改成本
	- 使用一系列重构手法， 在不改变软件可观察行为的前提下，调整其结构

- 为何重构
	- 改进软件设计， 软件结构会流失， 重构维持其现有形态
	- 让软件更易理解
	- 帮助找到bug
	- 提高编程速度

- 何时重构
	- 第一次就去做吧，第二次会不爽，忍忍， 第三次就重构吧
	- 添加功能时，如果发现不能轻松的添加你想要的功能，那就先重构他，然后再添加新功能
	- 代码复审时重构


- 怎么跟经理说
	- 质量驱动 - 提
	- 进度驱动 - 不提，直接重构


### 重构为什么有用
- 现状
	- 难以阅读，难以修改
	- 逻辑重复，难以修改
	- 添加新逻辑，修改现有代码，难以修改
	- 复杂逻辑条件，难以修改

- 目的
	- 容易阅读
	- 所有逻辑都只在唯一地点指定
	- 新的改动不会危及现有逻辑
	- 尽可能简单表达条件逻辑

### 间接层与重构
计算机是这样一门科学：它相信所有问题都可以通过增加一个间接层来解决，一顿还是两顿烧烤？

重构很多时候就是在增加间接层，大对象拆分成小对象，大函数拆成小函数
优点：
- 允许逻辑共享
- 分开解释意图和实现  
	- 其实就是给函数或者类取个好名字
- 隔离变化
- 封装条件逻辑

- 重构 VS 事前设计

## 代码的坏味道
什么时候需要重构呢？？
代码改动困难，牵一发而动全身时，一个相同处理逻辑遍地都是的时候，就重构吧。

- 重复代码
	- 重复代码永远是一个警告
- 过长函数
- 过大的类
- 过长的参数列表
- 发散式变化
	- 一个类收到多种情况变化的影响
- 散弹式修改
	- 一个变化引发多个类相应修改
- 依恋情结
	- 一个函数过度依赖于另外一个对象
- 数据泥团
	- 让有关联关系的数据组成一个对象，在对象内部进行一些处理
- 基本类型偏执
	- 不要介意使用一些小的类，比如数值和币种的money类
- Switch
	- 使用多态，状态类，子类继承等
- 平行继承体系
	- 干掉引用端的继承体系
- 冗余类
	- inline class
- 夸夸奇谈未来性
	- 需求实现不用太过超前
- 令人迷惑的暂时字段-class fileds
	- 将字段和与之相关的计算独立出来，作为一个新的函数对象维护
- 过度耦合的消息链条
	- 用函数替代对象链条
- 中间人 【过度委托】
- 类过于亲密
- 异曲同工的类
- 不完美的库类
- 纯粹的数据类
- 被拒绝的馈赠
	- 基类继承了过多的父类的实现，这个一般可以接受，如果不愿意实现父类的接口，就注意是否要继续继承，可以考虑是否要修改继承关系
- 过多的注释

## 构筑测试体系

可靠的测试体系是重构的前提。




## 写在最后
这本书后面部分大部分是一些具体的重构手法，会快速过一下，就不再笔记了。  

最大的收获莫过于减少了对重构的顾虑，更加重视自动测试体系，开始在EBS plsql开发的过程使用自动测试。  
开发过程中虽然多花了一些时间编写自动测试脚本，但是一旦编写完成，修改一点代码就可以很快的进行一次批量测试，对开发速度的提升还是很明显的。  

有了测试体系，该重构时就重构吧。




